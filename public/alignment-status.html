<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMTK Alignment Status - Fly Brain</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; }

        .header {
            background: #2c3e50; color: white; padding: 15px 30px;
            display: flex; align-items: center; justify-content: space-between;
        }
        .header h1 { font-size: 20px; }
        .header .nav { display: flex; align-items: center; gap: 10px; }
        .header button {
            background: #3498db; color: white; border: none; padding: 6px 14px;
            border-radius: 4px; cursor: pointer; font-size: 13px;
        }
        .header button:hover { background: #2980b9; }

        .container { max-width: 1200px; margin: 20px auto; padding: 0 20px; }

        .status-overview {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;
            margin-bottom: 30px;
        }
        .status-card {
            background: white; padding: 20px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
        }
        .status-card h3 { color: #2c3e50; margin-bottom: 10px; }
        .status-card .count { font-size: 2em; font-weight: bold; color: #3498db; }

        .section {
            background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .section h2 {
            color: #2c3e50; margin-bottom: 15px; padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .job-list { display: flex; flex-direction: column; gap: 10px; }
        .job-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 15px; border: 1px solid #ecf0f1; border-radius: 6px;
            background: #fafafa;
        }
        .job-item.preparing { background: #e8daef; border-color: #d2b4de; }
        .job-item.processing { background: #fff3cd; border-color: #ffeaa7; }
        .job-item.completed { background: #d4edda; border-color: #c3e6cb; }
        .job-item.failed { background: #f8d7da; border-color: #f5c6cb; }

        .job-info { flex: 1; }
        .job-name { font-weight: bold; color: #2c3e50; }
        .job-status { font-size: 12px; color: #7f8c8d; margin-top: 2px; }
        .job-time { font-size: 11px; color: #95a5a6; }

        .job-meta { text-align: right; font-size: 12px; }
        .queue-position { color: #e74c3c; font-weight: bold; }

        .loading {
            text-align: center; padding: 40px; color: #7f8c8d;
        }
        .loading .spinner {
            display: inline-block; width: 30px; height: 30px;
            border: 3px solid #ddd; border-top-color: #3498db;
            border-radius: 50%; animation: spin 0.8s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .empty-state {
            text-align: center; padding: 40px; color: #7f8c8d;
        }

        .refresh-btn {
            background: #27ae60; color: white; border: none; padding: 8px 16px;
            border-radius: 4px; cursor: pointer; font-size: 14px;
            margin-bottom: 20px;
        }
        .refresh-btn:hover { background: #229954; }

        .error-msg { color: #e74c3c; font-size: 12px; margin-top: 5px; }

        .retry-btn {
            background: #f39c12; color: white; border: none; padding: 4px 10px;
            border-radius: 3px; cursor: pointer; font-size: 11px; margin-top: 5px;
        }
        .retry-btn:hover { background: #e67e22; }

        .progress-bar-container {
            width: 100%; height: 20px; background: #ecf0f1; border-radius: 10px;
            overflow: hidden; margin-top: 8px;
        }
        .progress-bar {
            height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 10px; transition: width 0.5s ease;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 11px; font-weight: bold; min-width: 30px;
        }

        .stage-timeline { margin-top: 10px; }
        .stage-item {
            display: flex; align-items: center; gap: 8px;
            font-size: 12px; padding: 3px 0; color: #7f8c8d;
        }
        .stage-item.completed { color: #27ae60; }
        .stage-item.active { color: #2c3e50; font-weight: bold; }
        .stage-item .stage-icon { width: 16px; text-align: center; }
        .stage-item .stage-duration {
            margin-left: auto; font-family: monospace; font-size: 11px; color: #95a5a6;
        }
        .stage-item.completed .stage-duration { color: #27ae60; }
        .stage-item.active .stage-duration { color: #e67e22; }

        .elapsed-time { font-size: 12px; color: #e67e22; font-weight: bold; margin-left: 10px; }
        .total-time { font-size: 12px; color: #27ae60; font-weight: bold; margin-top: 2px; }

        .stage-toggle {
            background: none; border: 1px solid #bdc3c7; color: #7f8c8d;
            padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;
            margin-top: 6px;
        }
        .stage-toggle:hover { background: #ecf0f1; }
    </style>
</head>
<body>
    <div class="header">
        <h1>CMTK Alignment Status</h1>
        <div class="nav">
            <button onclick="window.location.href='/'">← Back to Review</button>
            <button onclick="queueAllApproved()">Queue All Approved</button>
            <button class="refresh-btn" onclick="loadStatus()">Refresh</button>
        </div>
    </div>

    <div class="container">
        <div class="status-overview">
            <div class="status-card">
                <h3>Queued</h3>
                <div class="count" id="queued-count">0</div>
            </div>
            <div class="status-card">
                <h3>Processing</h3>
                <div class="count" id="processing-count">0</div>
            </div>
            <div class="status-card">
                <h3>Completed</h3>
                <div class="count" id="completed-count">0</div>
            </div>
            <div class="status-card">
                <h3>Failed</h3>
                <div class="count" id="failed-count">0</div>
            </div>
            <div class="status-card">
                <h3>Approved</h3>
                <div class="count" id="approved-count">0</div>
            </div>
        </div>

        <div class="section">
            <h2>Currently Processing</h2>
            <div id="processing-section">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading status...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Queued Jobs</h2>
            <div id="queued-section">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading queue...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Completed Jobs</h2>
            <div id="completed-section">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading completed jobs...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Failed Jobs</h2>
            <div id="failed-section">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading failed jobs...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Approved Images (Ready to Queue)</h2>
            <div id="approved-section">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading approved images...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let statusData = null;

        function loadStatus() {
            Promise.all([
                fetch('/api/alignment-status').then(r => r.json()),
                fetch('/api/images').then(r => r.json()),
                fetch('/api/saved').then(r => r.json())
            ])
            .then(([status, images, saved]) => {
                statusData = status;
                updateOverview();
                renderProcessing();
                renderQueued();
                renderCompleted();
                renderFailed();
                renderApproved(images, saved);
                updateApprovedCount(images, saved);
            })
            .catch(err => {
                console.error('Failed to load status:', err);
                showError('Failed to load alignment status');
            });
        }

        function updateOverview() {
            const counts = {
                preparing: 0,
                queued: 0,
                processing: 0,
                completed: 0,
                failed: 0
            };

            statusData.forEach(job => {
                counts[job.status] = (counts[job.status] || 0) + 1;
            });

            document.getElementById('queued-count').textContent = (counts.preparing + counts.queued) || 0;
            document.getElementById('processing-count').textContent = counts.processing || 0;
            document.getElementById('completed-count').textContent = counts.completed || 0;
            document.getElementById('failed-count').textContent = counts.failed || 0;
        }

        function updateApprovedCount(images, savedData) {
            // Get approved images that haven't been queued/processed yet
            const queuedOrProcessed = new Set(statusData.map(job => job.image_base));
            const approvedCount = images.filter(img => {
                const imgBase = img.split('/').pop();
                return savedData[img] && savedData[img].approved && !queuedOrProcessed.has(imgBase);
            }).length;

            document.getElementById('approved-count').textContent = approvedCount;
        }

        function renderProcessing() {
            const processing = statusData.filter(job => job.status === 'processing');
            const container = document.getElementById('processing-section');

            if (processing.length === 0) {
                container.innerHTML = '<div class="empty-state">No jobs currently processing</div>';
                return;
            }

            const html = processing.map(job => {
                const progress = job.progress || 0;
                const stageName = job.stage_labels?.[job.current_stage] || job.current_stage || 'Unknown';
                const elapsed = job.started_at ? formatElapsed(job.started_at) : '';
                const stageTimeline = renderStageTimeline(job);

                return `
                    <div class="job-item processing">
                        <div class="job-info" style="width:100%">
                            <div style="display:flex; align-items:center; justify-content:space-between">
                                <div class="job-name">${job.image_base}</div>
                                <span class="elapsed-time" data-started="${job.started_at || ''}">&#9202; ${elapsed}</span>
                            </div>
                            <div class="job-status">Stage: ${stageName}</div>
                            <div class="progress-bar-container">
                                <div class="progress-bar" style="width:${Math.max(progress, 2)}%">${progress}%</div>
                            </div>
                            <button class="stage-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">Show stages</button>
                            <div class="stage-timeline" style="display:none">${stageTimeline}</div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="job-list">${html}</div>`;
        }

        function renderQueued() {
            const preparing = statusData.filter(job => job.status === 'preparing');
            const queued = statusData.filter(job => job.status === 'queued');
            const all = [...preparing, ...queued];
            const container = document.getElementById('queued-section');

            if (all.length === 0) {
                container.innerHTML = '<div class="empty-state">No jobs in queue</div>';
                return;
            }

            const html = all.map(job => {
                const isPreparing = job.status === 'preparing';
                return `
                    <div class="job-item${isPreparing ? ' preparing' : ''}">
                        <div class="job-info">
                            <div class="job-name">${job.image_base}</div>
                            <div class="job-status">${isPreparing ? 'Preparing channels since' : 'Queued at'} ${formatTime(job.queued_at)}</div>
                        </div>
                        <div class="job-meta">
                            <div class="queue-position">${isPreparing ? 'PREPARING' : 'Position ' + job.queue_position}</div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="job-list">${html}</div>`;
        }

        function renderCompleted() {
            const completed = statusData.filter(job => job.status === 'completed')
                .sort((a, b) => new Date(b.completed_at) - new Date(a.completed_at));
            const container = document.getElementById('completed-section');

            if (completed.length === 0) {
                container.innerHTML = '<div class="empty-state">No completed jobs</div>';
                return;
            }

            const html = completed.map(job => {
                const totalTime = (job.started_at && job.completed_at)
                    ? formatDuration((new Date(job.completed_at) - new Date(job.started_at)) / 1000)
                    : '';
                const stageTimeline = renderStageTimeline(job);

                return `
                    <div class="job-item completed">
                        <div class="job-info" style="width:100%">
                            <div style="display:flex; align-items:center; justify-content:space-between">
                                <div class="job-name">${job.image_base}</div>
                                <div>&#9989; Success</div>
                            </div>
                            <div class="job-status">Completed ${formatTime(job.completed_at)}</div>
                            ${totalTime ? `<div class="total-time">Total: ${totalTime}</div>` : ''}
                            <button class="stage-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">Show stages</button>
                            <div class="stage-timeline" style="display:none">${stageTimeline}</div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="job-list">${html}</div>`;
        }

        function renderFailed() {
            const failed = statusData.filter(job => job.status === 'failed')
                .sort((a, b) => new Date(b.completed_at || b.queued_at) - new Date(a.completed_at || a.queued_at));
            const container = document.getElementById('failed-section');

            if (failed.length === 0) {
                container.innerHTML = '<div class="empty-state">No failed jobs</div>';
                return;
            }

            const html = failed.map(job => {
                const failedStage = job.stage_labels?.[job.current_stage] || job.current_stage || '';
                const stageTimeline = renderStageTimeline(job);

                return `
                    <div class="job-item failed">
                        <div class="job-info" style="width:100%">
                            <div style="display:flex; align-items:center; justify-content:space-between">
                                <div class="job-name">${job.image_base}</div>
                                <div>
                                    &#10060; Failed
                                    <button class="retry-btn" onclick="retryJob('${job.image_base}')">Retry</button>
                                </div>
                            </div>
                            <div class="job-status">Failed ${formatTime(job.completed_at)}${failedStage ? ` at stage: ${failedStage}` : ''}</div>
                            <div class="error-msg">${job.error || 'Unknown error'}</div>
                            ${Object.keys(job.stages || {}).length > 0 ? `
                                <button class="stage-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">Show stages</button>
                                <div class="stage-timeline" style="display:none">${stageTimeline}</div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="job-list">${html}</div>`;
        }

        function renderApproved(images, savedData) {
            // Get approved images that haven't been queued/processed yet
            const queuedOrProcessed = new Set(statusData.map(job => job.image_base));
            const approvedImages = images.filter(img => {
                const imgBase = img.split('/').pop();
                return savedData[img] && savedData[img].approved && !queuedOrProcessed.has(imgBase);
            });

            const container = document.getElementById('approved-section');

            if (approvedImages.length === 0) {
                container.innerHTML = '<div class="empty-state">No approved images ready to queue</div>';
                return;
            }

            const html = approvedImages.map(imageName => {
                const imgBase = imageName.split('/').pop();
                const approvedAt = savedData[imageName].approved_at;
                return `
                    <div class="job-item">
                        <div class="job-info">
                            <div class="job-name">${imgBase}</div>
                            <div class="job-status">Approved ${approvedAt ? formatTime(approvedAt) : 'recently'}</div>
                        </div>
                        <div class="job-meta">
                            <div>✅ Approved</div>
                            <button class="queue-btn" onclick="queueSingle('${imgBase}')">Queue for Alignment</button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="job-list">${html}</div>`;
        }

        async function retryJob(imageBase) {
            try {
                const response = await fetch('/api/queue-alignment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image_base: imageBase })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                if (result.success) {
                    alert(`Successfully re-queued ${imageBase} for alignment`);
                    loadStatus(); // Refresh the status
                } else {
                    throw new Error(result.error || 'Failed to queue alignment');
                }
            } catch (error) {
                showError(`Failed to retry ${imageBase}: ${error.message}`);
            }
        }

        async function queueSingle(imageBase) {
            try {
                const response = await fetch('/api/queue-alignment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image_base: imageBase })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                if (result.success) {
                    alert(`Successfully queued ${imageBase} for alignment`);
                    loadStatus(); // Refresh the status
                } else {
                    throw new Error(result.error || 'Failed to queue alignment');
                }
            } catch (error) {
                showError(`Failed to queue ${imageBase}: ${error.message}`);
            }
        }

        async function queueAllApproved() {
            try {
                // Get all images
                const imagesResponse = await fetch('/api/images');
                if (!imagesResponse.ok) {
                    throw new Error(`HTTP ${imagesResponse.status}: ${imagesResponse.statusText}`);
                }
                const images = await imagesResponse.json();

                // Get saved data to find approved images
                const savedResponse = await fetch('/api/saved');
                if (!savedResponse.ok) {
                    throw new Error(`HTTP ${savedResponse.status}: ${savedResponse.statusText}`);
                }
                const savedData = await savedResponse.json();

                // Filter images that are approved
                const approvedImages = images.filter(img => savedData[img] && savedData[img].approved);
                if (approvedImages.length === 0) {
                    alert('No approved images found');
                    return;
                }

                let successCount = 0;
                let errorCount = 0;

                // Queue each approved image
                for (const imageName of approvedImages) {
                    try {
                        // Extract base name (remove directory prefix)
                        const imageBase = imageName.split('/').pop();
                        const queueResponse = await fetch('/api/queue-alignment', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ image_base: imageBase })
                        });

                        if (queueResponse.ok) {
                            const result = await queueResponse.json();
                            if (result.success) {
                                successCount++;
                            } else {
                                errorCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Failed to queue ${imageName}:`, error);
                    }
                }

                alert(`Queued ${successCount} images successfully${errorCount > 0 ? `, ${errorCount} failed` : ''}`);
                loadStatus(); // Refresh the status

            } catch (error) {
                showError(`Failed to queue approved images: ${error.message}`);
            }
        }

        function formatTime(isoString) {
            if (!isoString) return 'Unknown';
            const date = new Date(isoString);
            return date.toLocaleString();
        }

        function formatDuration(seconds) {
            if (seconds == null || isNaN(seconds)) return '';
            if (seconds < 60) return `${Math.round(seconds)}s`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${Math.round(seconds % 60)}s`;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            return `${h}h ${m}m`;
        }

        function formatElapsed(startIso) {
            if (!startIso) return '';
            const seconds = (Date.now() - new Date(startIso).getTime()) / 1000;
            return formatDuration(seconds);
        }

        const ALL_STAGES = [
            'set_lps', 'initial_affine', 'affine_registration',
            'warp', 'reformat_signal', 'reformat_background', 'thumbnails'
        ];

        function renderStageTimeline(job) {
            const stages = job.stages || {};
            const currentStage = job.current_stage;
            const labels = job.stage_labels || {};

            return ALL_STAGES.map(stage => {
                const info = stages[stage];
                const label = labels[stage] || stage;
                let icon = '&#9675;'; // empty circle
                let cls = '';
                let duration = '';

                if (info && info.completed_at) {
                    icon = '&#10003;'; // checkmark
                    cls = 'completed';
                    duration = info.duration_seconds != null ? formatDuration(info.duration_seconds) : '';
                } else if (info && info.started_at && !info.completed_at) {
                    icon = '&#9654;'; // play
                    cls = 'active';
                    duration = formatElapsed(info.started_at);
                } else if (stage === currentStage) {
                    icon = '&#9654;';
                    cls = 'active';
                }

                return `<div class="stage-item ${cls}">
                    <span class="stage-icon">${icon}</span>
                    <span>${label}</span>
                    <span class="stage-duration">${duration}</span>
                </div>`;
            }).join('');
        }

        function showError(message) {
            // Simple error display - could be enhanced
            alert(message);
        }

        // Auto-refresh every 10 seconds
        setInterval(loadStatus, 10000);

        // Update elapsed times every second without re-fetching
        setInterval(() => {
            document.querySelectorAll('.elapsed-time[data-started]').forEach(el => {
                const started = el.getAttribute('data-started');
                if (started) el.textContent = '\u23F2 ' + formatElapsed(started);
            });
            document.querySelectorAll('.stage-item.active .stage-duration').forEach(el => {
                const row = el.closest('.stage-timeline');
                if (!row) return;
                const activeItems = row.querySelectorAll('.stage-item.active');
                activeItems.forEach(item => {
                    // Re-render would need start time; skip for now — covered by 10s refresh
                });
            });
        }, 1000);

        // Initial load
        loadStatus();
    </script>
</body>
</html>