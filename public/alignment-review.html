<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alignment Review - Fly Brain</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; }

        .header {
            background: #2c3e50; color: white; padding: 15px 30px;
            display: flex; align-items: center; justify-content: space-between;
        }
        .header h1 { font-size: 20px; }
        .header .nav { display: flex; align-items: center; gap: 10px; }
        .header button {
            background: #3498db; color: white; border: none; padding: 6px 14px;
            border-radius: 4px; cursor: pointer; font-size: 13px;
        }
        .header button:hover { background: #2980b9; }

        .container { max-width: 1400px; margin: 20px auto; padding: 0 20px; }

        /* ── Gallery View ── */
        .gallery-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px;
        }
        .gallery-header h2 { color: #2c3e50; }
        .gallery-header .count { color: #7f8c8d; font-size: 14px; }

        .gallery-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px; margin-bottom: 30px;
        }
        .gallery-card {
            background: white; border-radius: 8px; overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: pointer;
            transition: box-shadow 0.2s, transform 0.1s;
            border: 3px solid transparent;
        }
        .gallery-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15); transform: translateY(-2px); }
        .gallery-card.active { border-color: #3498db; }
        .gallery-card .card-thumbs {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 2px;
            background: #1a1a1a; padding: 2px;
        }
        .gallery-card .card-thumbs img { width: 100%; height: auto; display: block; }
        .gallery-card .card-info { padding: 12px; }
        .gallery-card .card-title { font-weight: bold; font-size: 13px; color: #2c3e50; word-break: break-all; }
        .gallery-card .card-meta { font-size: 11px; color: #7f8c8d; margin-top: 4px; }
        .gallery-card .card-template { font-size: 11px; color: #27ae60; margin-top: 2px; }

        /* ── Detail View ── */
        .detail-panel {
            background: white; border-radius: 8px; padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 30px;
            display: none;
        }
        .detail-panel.visible { display: block; }

        .detail-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 10px;
        }
        .detail-header h2 { color: #2c3e50; font-size: 18px; word-break: break-all; }
        .detail-nav { display: flex; gap: 8px; align-items: center; }
        .detail-nav button {
            background: #ecf0f1; color: #2c3e50; border: none; padding: 6px 14px;
            border-radius: 4px; cursor: pointer; font-size: 13px;
        }
        .detail-nav button:hover { background: #bdc3c7; }
        .detail-nav button:disabled { opacity: 0.4; cursor: default; }
        .detail-nav .position { font-size: 12px; color: #7f8c8d; }
        .close-detail {
            background: #e74c3c !important; color: white !important;
        }
        .close-detail:hover { background: #c0392b !important; }

        .detail-meta {
            display: flex; gap: 20px; margin-bottom: 16px; font-size: 13px; color: #7f8c8d;
            flex-wrap: wrap;
        }
        .detail-meta span { background: #ecf0f1; padding: 4px 10px; border-radius: 4px; }

        /* ── View Mode Controls ── */
        .view-controls {
            display: flex; align-items: center; gap: 16px; margin-bottom: 20px;
            padding: 12px 16px; background: #f8f9fa; border-radius: 6px;
            flex-wrap: wrap;
        }
        .view-controls label { font-size: 13px; font-weight: bold; color: #2c3e50; }
        .mode-buttons { display: flex; gap: 4px; }
        .mode-btn {
            padding: 6px 14px; border: 1px solid #bdc3c7; background: white;
            border-radius: 4px; cursor: pointer; font-size: 12px; color: #2c3e50;
        }
        .mode-btn.active { background: #3498db; color: white; border-color: #3498db; }
        .mode-btn:hover:not(.active) { background: #ecf0f1; }

        .opacity-control { display: flex; align-items: center; gap: 8px; }
        .opacity-control input[type="range"] { width: 160px; }
        .opacity-control .opacity-label { font-size: 11px; color: #7f8c8d; min-width: 30px; }

        .legend {
            display: flex; align-items: center; gap: 12px; font-size: 11px;
            margin-left: auto;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-swatch {
            width: 14px; height: 14px; border-radius: 2px; display: inline-block;
        }

        /* ── Comparison Grid ── */
        .comparison-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;
        }
        .comparison-axis {
            border: 1px solid #ecf0f1; border-radius: 8px; overflow: hidden;
        }
        .comparison-axis h3 {
            text-align: center; padding: 8px; background: #f8f9fa;
            font-size: 13px; color: #2c3e50; border-bottom: 1px solid #ecf0f1;
        }
        .comparison-content { padding: 8px; background: #1a1a1a; }
        .comparison-content canvas,
        .comparison-content img {
            width: 100%; height: auto; display: block; border-radius: 4px;
        }

        /* Side-by-side sub-grid */
        .side-by-side {
            display: grid; grid-template-columns: 1fr 1fr; gap: 4px;
        }
        .side-by-side .sub-label {
            text-align: center; font-size: 10px; color: #95a5a6;
            padding: 4px 0 0;
        }

        /* ── Signal row ── */
        .signal-section {
            margin-top: 20px; padding-top: 16px; border-top: 2px solid #ecf0f1;
        }
        .signal-section h3 { color: #2c3e50; margin-bottom: 12px; }
        .signal-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;
        }
        .signal-axis {
            border: 1px solid #ecf0f1; border-radius: 8px; overflow: hidden;
        }
        .signal-axis h4 {
            text-align: center; padding: 6px; background: #f8f9fa;
            font-size: 12px; color: #2c3e50;
        }
        .signal-axis .signal-img { padding: 8px; background: #1a1a1a; }
        .signal-axis img { width: 100%; height: auto; display: block; border-radius: 4px; }

        /* ── Responsive ── */
        @media (max-width: 900px) {
            .comparison-grid, .signal-grid { grid-template-columns: 1fr; }
            .gallery-grid { grid-template-columns: 1fr 1fr; }
        }
        @media (max-width: 600px) {
            .gallery-grid { grid-template-columns: 1fr; }
        }

        .loading { text-align: center; padding: 60px; color: #7f8c8d; }
        .loading .spinner {
            display: inline-block; width: 30px; height: 30px;
            border: 3px solid #ddd; border-top-color: #3498db;
            border-radius: 50%; animation: spin 0.8s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .empty-state { text-align: center; padding: 60px; color: #7f8c8d; }

        .regen-btn {
            background: #f39c12; color: white; border: none; padding: 6px 14px;
            border-radius: 4px; cursor: pointer; font-size: 12px;
        }
        .regen-btn:hover { background: #e67e22; }
        .regen-btn:disabled { opacity: 0.5; cursor: wait; }

        /* Approval buttons */
        .approval-row {
            display: flex; gap: 12px; align-items: center;
            margin-top: 16px; padding-top: 16px; border-top: 2px solid #ecf0f1;
            flex-wrap: wrap;
        }
        .btn-approve {
            padding: 8px 20px; border: none; border-radius: 4px; cursor: pointer;
            font-size: 13px; font-weight: bold; background: #27ae60; color: white;
        }
        .btn-approve:hover { background: #1e8449; }
        .btn-approve:disabled { opacity: 0.5; cursor: default; }
        .btn-reject {
            padding: 8px 20px; border: none; border-radius: 4px; cursor: pointer;
            font-size: 13px; font-weight: bold; background: #e74c3c; color: white;
        }
        .btn-reject:hover { background: #c0392b; }
        .btn-reject:disabled { opacity: 0.5; cursor: default; }
        .approval-status {
            font-size: 13px; color: #7f8c8d; margin-left: auto;
        }

        /* Status badge on gallery cards */
        .card-status-badge {
            display: inline-block; padding: 2px 8px; border-radius: 10px;
            font-size: 10px; font-weight: bold; text-transform: uppercase;
            margin-top: 4px;
        }
        .card-status-badge.pending { background: #fdebd0; color: #e67e22; }
        .card-status-badge.approved { background: #d5f5e3; color: #27ae60; }
        .card-status-badge.rejected { background: #fadbd8; color: #e74c3c; }

        .gallery-card.approved-card { border-color: #27ae60; }
        .gallery-card.rejected-card { border-color: #e74c3c; }

        /* Gallery filter bar */
        .gallery-filter {
            display: flex; gap: 8px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;
        }
        .gallery-filter-label { font-size: 13px; font-weight: bold; color: #7f8c8d; }
        .gallery-filter-btn {
            padding: 5px 12px; border: 1px solid #bdc3c7; border-radius: 14px;
            background: white; color: #7f8c8d; cursor: pointer; font-size: 12px;
        }
        .gallery-filter-btn:hover { background: #ecf0f1; }
        .gallery-filter-btn.active { background: #3498db; color: white; border-color: #3498db; }
        .gallery-filter-btn .gf-count {
            display: inline-block; min-width: 14px; text-align: center;
            background: rgba(0,0,0,0.1); border-radius: 7px; padding: 0 4px;
            font-size: 10px; margin-left: 3px;
        }
        .gallery-filter-btn.active .gf-count { background: rgba(255,255,255,0.3); }
    </style>
</head>
<body>
    <div class="header">
        <h1>Alignment Review</h1>
        <div class="nav">
            <button onclick="window.location.href='/'">&#8592; Image Review</button>
            <button onclick="window.location.href='/alignment-status.html'">Alignment Status</button>
        </div>
    </div>

    <div class="container">
        <!-- Detail Panel (shown when image selected) -->
        <div class="detail-panel" id="detail-panel">
            <div class="detail-header">
                <h2 id="detail-title">—</h2>
                <div class="detail-nav">
                    <button id="prev-btn" onclick="navigate(-1)">&#9664; Prev</button>
                    <span class="position" id="nav-position">1 / 1</span>
                    <button id="next-btn" onclick="navigate(1)">Next &#9654;</button>
                    <button class="close-detail" onclick="closeDetail()">&#10005; Close</button>
                </div>
            </div>

            <div class="detail-meta" id="detail-meta"></div>

            <!-- View mode controls -->
            <div class="view-controls">
                <label>View:</label>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="overlay" onclick="setMode('overlay')">Overlay</button>
                    <button class="mode-btn" data-mode="side-by-side" onclick="setMode('side-by-side')">Side by Side</button>
                    <button class="mode-btn" data-mode="blend" onclick="setMode('blend')">Blend</button>
                </div>

                <div class="opacity-control" id="opacity-control" style="display:none;">
                    <span style="font-size:12px;">Template</span>
                    <input type="range" id="opacity-slider" min="0" max="100" value="50"
                        oninput="updateBlend(this.value)">
                    <span style="font-size:12px;">Aligned</span>
                    <span class="opacity-label" id="opacity-label">50%</span>
                </div>

                <div class="legend" id="overlay-legend">
                    <div class="legend-item">
                        <span class="legend-swatch" style="background:#ff00ff;"></span> Template
                    </div>
                    <div class="legend-item">
                        <span class="legend-swatch" style="background:#00ff00;"></span> Aligned
                    </div>
                    <div class="legend-item">
                        <span class="legend-swatch" style="background:#ffffff;"></span> Match
                    </div>
                </div>

                <button class="regen-btn" id="regen-btn" onclick="regenerateThumbnails()"
                    title="Re-generate thumbnails with overlay (for alignments completed before this feature)">
                    &#x21BB; Regenerate Thumbnails
                </button>
            </div>

            <!-- Comparison views -->
            <div id="comparison-container"></div>

            <!-- Signal-on-Template section -->
            <div class="signal-section" id="signal-on-template-section" style="display:none;">
                <h3>Signal (green) on Template (magenta)</h3>
                <div class="signal-grid" id="signal-on-template-grid"></div>
            </div>

            <!-- Signal section -->
            <div class="signal-section" id="signal-section" style="display:none;">
                <h3>Aligned Signal Channel</h3>
                <div class="signal-grid" id="signal-grid"></div>
            </div>

            <!-- Approval row -->
            <div class="approval-row" id="approval-row">
                <button class="btn-approve" id="approve-alignment-btn" onclick="approveAlignment()">&#10003; Approve Alignment</button>
                <button class="btn-reject" id="reject-alignment-btn" onclick="rejectAlignment()">&#10007; Reject &amp; Re-orient</button>
                <span class="approval-status" id="approval-status-text"></span>
            </div>
        </div>

        <!-- Gallery -->
        <div class="gallery-header">
            <h2>Completed Alignments</h2>
            <span class="count" id="gallery-count"></span>
        </div>
        <div class="gallery-filter" id="gallery-filter">
            <span class="gallery-filter-label">Show:</span>
            <button class="gallery-filter-btn active" data-gf="all" onclick="applyGalleryFilter('all')">All <span class="gf-count" id="gf-count-all">0</span></button>
            <button class="gallery-filter-btn" data-gf="pending" onclick="applyGalleryFilter('pending')">Pending Review <span class="gf-count" id="gf-count-pending">0</span></button>
            <button class="gallery-filter-btn" data-gf="approved" onclick="applyGalleryFilter('approved')">Approved <span class="gf-count" id="gf-count-approved">0</span></button>
            <button class="gallery-filter-btn" data-gf="rejected" onclick="applyGalleryFilter('rejected')">Rejected <span class="gf-count" id="gf-count-rejected">0</span></button>
        </div>
        <div id="gallery-container">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading completed alignments...</p>
            </div>
        </div>
    </div>

    <script>
        let allJobs = [];       // completed alignment jobs
        let displayedJobs = []; // filtered jobs shown in gallery
        let thumbnailCache = {};// image_base -> thumbnail data
        let orientationsData = {};
        let currentIndex = -1;
        let currentMode = 'overlay';
        let currentGalleryFilter = 'all';

        // ────────────────────────────
        // Helper: get approval status for a job
        // ────────────────────────────
        function getApprovalStatus(job) {
            const key = job._savedKey;
            if (!key) return 'pending';
            const entry = orientationsData[key];
            if (!entry) return 'pending';
            if (entry.alignment_approved) return 'approved';
            if (entry.alignment_rejected) return 'rejected';
            return 'pending';
        }

        // ────────────────────────────
        // Data loading
        // ────────────────────────────
        async function loadData() {
            try {
                const [statusRes, savedRes] = await Promise.all([
                    fetch('/api/alignment-status').then(r => r.json()),
                    fetch('/api/saved').then(r => r.json())
                ]);

                orientationsData = savedRes;

                allJobs = statusRes
                    .filter(j => j.status === 'completed')
                    .sort((a, b) => new Date(b.completed_at) - new Date(a.completed_at));

                // Attach saved metadata
                allJobs.forEach(job => {
                    const key = Object.keys(savedRes).find(k => k.split('/').pop() === job.image_base);
                    if (key) job._savedKey = key;
                });

                applyGalleryFilter(currentGalleryFilter);

                // Check URL hash for direct link
                if (window.location.hash) {
                    const target = decodeURIComponent(window.location.hash.slice(1));
                    const idx = displayedJobs.findIndex(j => j.image_base === target);
                    if (idx >= 0) selectImage(idx);
                }
            } catch (err) {
                document.getElementById('gallery-container').innerHTML =
                    '<div class="empty-state">Failed to load alignment data. Check server connection.</div>';
                console.error(err);
            }
        }

        async function loadThumbnails(imageBase) {
            if (thumbnailCache[imageBase]) return thumbnailCache[imageBase];
            const res = await fetch(`/api/alignment-thumbnails?image_base=${encodeURIComponent(imageBase)}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            thumbnailCache[imageBase] = data;
            return data;
        }

        // ────────────────────────────
        // Gallery filtering
        // ────────────────────────────
        function applyGalleryFilter(filter) {
            currentGalleryFilter = filter;
            document.querySelectorAll('.gallery-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.gf === filter);
            });

            // Compute counts
            const counts = { all: allJobs.length, pending: 0, approved: 0, rejected: 0 };
            allJobs.forEach(job => {
                const st = getApprovalStatus(job);
                if (counts[st] !== undefined) counts[st]++;
            });
            Object.keys(counts).forEach(k => {
                const el = document.getElementById(`gf-count-${k}`);
                if (el) el.textContent = counts[k];
            });

            if (filter === 'all') {
                displayedJobs = [...allJobs];
            } else {
                displayedJobs = allJobs.filter(job => getApprovalStatus(job) === filter);
            }

            renderGallery();
        }

        // ────────────────────────────
        // Gallery rendering
        // ────────────────────────────
        function renderGallery() {
            const container = document.getElementById('gallery-container');
            const countEl = document.getElementById('gallery-count');
            countEl.textContent = `${displayedJobs.length} completed alignment${displayedJobs.length !== 1 ? 's' : ''}`;

            if (displayedJobs.length === 0) {
                container.innerHTML = '<div class="empty-state">No alignments match the current filter. Queue images for alignment from the <a href="/">Image Review</a> page.</div>';
                return;
            }

            const grid = document.createElement('div');
            grid.className = 'gallery-grid';

            displayedJobs.forEach((job, idx) => {
                const card = document.createElement('div');
                const approvalSt = getApprovalStatus(job);
                let cardClass = 'gallery-card' + (idx === currentIndex ? ' active' : '');
                if (approvalSt === 'approved') cardClass += ' approved-card';
                if (approvalSt === 'rejected') cardClass += ' rejected-card';
                card.className = cardClass;
                card.onclick = () => selectImage(idx);

                const duration = (job.started_at && job.completed_at)
                    ? formatDuration((new Date(job.completed_at) - new Date(job.started_at)) / 1000)
                    : '';

                const badgeLabels = { pending: 'Pending Review', approved: 'Approved \u2713', rejected: 'Rejected \u2717' };
                const badgeHtml = `<span class="card-status-badge ${approvalSt}">${badgeLabels[approvalSt]}</span>`;

                card.innerHTML = `
                    <div class="card-thumbs" id="card-thumbs-${idx}">
                        <div style="background:#2a2a2a; aspect-ratio:1; display:flex; align-items:center; justify-content:center; color:#555; font-size:11px;">Loading...</div>
                        <div style="background:#2a2a2a; aspect-ratio:1;"></div>
                        <div style="background:#2a2a2a; aspect-ratio:1;"></div>
                    </div>
                    <div class="card-info">
                        <div class="card-title">${job.image_base}</div>
                        <div class="card-meta">${formatTime(job.completed_at)}${duration ? ' &middot; ' + duration : ''}</div>
                        ${badgeHtml}
                    </div>
                `;
                grid.appendChild(card);

                // Load thumbnails async for gallery cards
                loadThumbnails(job.image_base).then(data => {
                    const thumbDiv = document.getElementById(`card-thumbs-${idx}`);
                    if (!thumbDiv) return;
                    const axes = ['x', 'y', 'z'];
                    // Prefer overlay thumbnails for gallery, fall back to aligned
                    thumbDiv.innerHTML = axes.map(ax => {
                        const src = data.thumbnails[`${ax}_overlay`] || data.thumbnails[`${ax}_aligned`];
                        return src
                            ? `<img src="data:image/png;base64,${src}" alt="${ax}">`
                            : `<div style="background:#2a2a2a; aspect-ratio:1;"></div>`;
                    }).join('');
                }).catch(() => {});
            });

            container.innerHTML = '';
            container.appendChild(grid);
        }

        // ────────────────────────────
        // Detail view
        // ────────────────────────────
        async function selectImage(idx) {
            currentIndex = idx;
            const job = displayedJobs[idx];
            window.location.hash = encodeURIComponent(job.image_base);

            // Highlight active card
            document.querySelectorAll('.gallery-card').forEach((c, i) => {
                c.classList.toggle('active', i === idx);
            });

            const panel = document.getElementById('detail-panel');
            panel.classList.add('visible');
            panel.scrollIntoView({ behavior: 'smooth', block: 'start' });

            document.getElementById('detail-title').textContent = job.image_base;
            updateNav();

            // Update approval status display
            updateApprovalUI(job);

            // Meta info
            const duration = (job.started_at && job.completed_at)
                ? formatDuration((new Date(job.completed_at) - new Date(job.started_at)) / 1000)
                : '';
            let metaHtml = '';
            metaHtml += `<span>Completed: ${formatTime(job.completed_at)}</span>`;
            if (duration) metaHtml += `<span>Duration: ${duration}</span>`;
            document.getElementById('detail-meta').innerHTML = metaHtml;

            // Load thumbnails
            try {
                const data = await loadThumbnails(job.image_base);
                if (data.template) {
                    document.getElementById('detail-meta').innerHTML += `<span>Template: ${data.template.replace(/_lps\.nrrd$/, '')}</span>`;
                }
                renderComparison(data);
            } catch (err) {
                document.getElementById('comparison-container').innerHTML =
                    '<div class="empty-state">Failed to load thumbnails for this image.</div>';
                document.getElementById('signal-section').style.display = 'none';
                document.getElementById('signal-on-template-section').style.display = 'none';
                console.error(err);
            }
        }

        function updateApprovalUI(job) {
            const approvalSt = getApprovalStatus(job);
            const approveBtn = document.getElementById('approve-alignment-btn');
            const rejectBtn = document.getElementById('reject-alignment-btn');
            const statusText = document.getElementById('approval-status-text');

            // Always reset button text in case a previous action left them modified
            approveBtn.textContent = '\u2713 Approve Alignment';
            rejectBtn.textContent = '\u2717 Reject & Re-orient';

            if (approvalSt === 'approved') {
                approveBtn.disabled = true;
                rejectBtn.disabled = false;
                const entry = orientationsData[job._savedKey];
                statusText.innerHTML = '\u2714 Alignment approved' + (entry && entry.alignment_approved_at ? ' at ' + formatTime(entry.alignment_approved_at) : '');
                statusText.style.color = '#27ae60';
            } else if (approvalSt === 'rejected') {
                approveBtn.disabled = false;
                rejectBtn.disabled = true;
                const entry = orientationsData[job._savedKey];
                const reason = entry && entry.alignment_rejection_reason ? ' — ' + entry.alignment_rejection_reason : '';
                statusText.innerHTML = '\u2717 Alignment rejected' + reason;
                statusText.style.color = '#e74c3c';
            } else {
                approveBtn.disabled = false;
                rejectBtn.disabled = false;
                statusText.innerHTML = 'Pending review';
                statusText.style.color = '#7f8c8d';
            }
        }

        function renderComparison(data) {
            const container = document.getElementById('comparison-container');
            const th = data.thumbnails;
            const hasOverlay = !!th.x_overlay;

            // If no overlay thumbnails, show info and default to side-by-side
            if (!hasOverlay && currentMode === 'overlay') {
                setMode('side-by-side');
            }

            // Build comparison for each axis
            const axes = [
                { key: 'x', label: 'X-Axis (Dorsal View)' },
                { key: 'y', label: 'Y-Axis (Lateral View)' },
                { key: 'z', label: 'Z-Axis (Anterior View)' }
            ];

            let html = '<div class="comparison-grid">';
            axes.forEach(ax => {
                html += `
                    <div class="comparison-axis">
                        <h3>${ax.label}</h3>
                        <div class="comparison-content" id="comp-${ax.key}"></div>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;

            // Render based on mode
            applyMode(data);

            // Signal section
            const signalSection = document.getElementById('signal-section');
            const hasSignal = !!th.x_signal;
            if (hasSignal) {
                signalSection.style.display = 'block';
                const signalGrid = document.getElementById('signal-grid');
                signalGrid.innerHTML = axes.map(ax => `
                    <div class="signal-axis">
                        <h4>${ax.label}</h4>
                        <div class="signal-img">
                            <img src="data:image/png;base64,${th[`${ax.key}_signal`]}" alt="Signal ${ax.key}">
                        </div>
                    </div>
                `).join('');

                // Signal-on-template (client-side compositing)
                const sotSection = document.getElementById('signal-on-template-section');
                sotSection.style.display = 'block';
                const sotGrid = document.getElementById('signal-on-template-grid');
                sotGrid.innerHTML = axes.map(ax => `
                    <div class="signal-axis">
                        <h4>${ax.label}</h4>
                        <div class="signal-img">
                            <canvas id="sot-canvas-${ax.key}" style="width:100%;height:auto;border-radius:4px;"></canvas>
                        </div>
                    </div>
                `).join('');

                // Draw signal-on-template overlay canvases
                axes.forEach(ax => {
                    drawSignalOnTemplate(ax.key, th[`${ax.key}_template`], th[`${ax.key}_signal`]);
                });
            } else {
                signalSection.style.display = 'none';
                document.getElementById('signal-on-template-section').style.display = 'none';
            }
        }

        function applyMode(data) {
            if (!data) return;
            const th = data.thumbnails;
            const axes = ['x', 'y', 'z'];

            // Update mode button state
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentMode);
            });

            const opacityCtrl = document.getElementById('opacity-control');
            const legend = document.getElementById('overlay-legend');
            opacityCtrl.style.display = currentMode === 'blend' ? 'flex' : 'none';
            legend.style.display = currentMode === 'overlay' ? 'flex' : 'none';

            axes.forEach(ax => {
                const el = document.getElementById(`comp-${ax}`);
                if (!el) return;

                if (currentMode === 'overlay') {
                    if (th[`${ax}_overlay`]) {
                        el.innerHTML = `<img src="data:image/png;base64,${th[`${ax}_overlay`]}" alt="Overlay ${ax}">`;
                    } else {
                        // Client-side fallback: draw overlay using canvas
                        el.innerHTML = `<canvas id="canvas-${ax}" style="width:100%;height:auto;"></canvas>`;
                        drawOverlayCanvas(ax, th[`${ax}_template`], th[`${ax}_aligned`]);
                    }
                } else if (currentMode === 'side-by-side') {
                    el.innerHTML = `
                        <div class="side-by-side">
                            <div>
                                <img src="data:image/png;base64,${th[`${ax}_template`]}" alt="Template ${ax}">
                                <div class="sub-label">Template</div>
                            </div>
                            <div>
                                <img src="data:image/png;base64,${th[`${ax}_aligned`]}" alt="Aligned ${ax}">
                                <div class="sub-label">Aligned</div>
                            </div>
                        </div>
                    `;
                } else if (currentMode === 'blend') {
                    el.innerHTML = `<canvas id="canvas-${ax}" style="width:100%;height:auto;"></canvas>`;
                    const val = document.getElementById('opacity-slider').value;
                    drawBlendCanvas(ax, th[`${ax}_template`], th[`${ax}_aligned`], val / 100);
                }
            });
        }

        function setMode(mode) {
            currentMode = mode;
            const job = allJobs[currentIndex];
            if (job && thumbnailCache[job.image_base]) {
                applyMode(thumbnailCache[job.image_base]);
            }
        }

        function updateBlend(val) {
            document.getElementById('opacity-label').textContent = val + '%';
            const job = allJobs[currentIndex];
            if (!job || !thumbnailCache[job.image_base]) return;
            const th = thumbnailCache[job.image_base].thumbnails;
            ['x', 'y', 'z'].forEach(ax => {
                drawBlendCanvas(ax, th[`${ax}_template`], th[`${ax}_aligned`], val / 100);
            });
        }

        // ────────────────────────────
        // Canvas compositing
        // ────────────────────────────
        function loadImageFromBase64(b64) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = `data:image/png;base64,${b64}`;
            });
        }

        async function drawOverlayCanvas(axis, templateB64, alignedB64) {
            const canvas = document.getElementById(`canvas-${axis}`);
            if (!canvas) return;

            const [tImg, aImg] = await Promise.all([
                loadImageFromBase64(templateB64),
                loadImageFromBase64(alignedB64)
            ]);

            const w = Math.max(tImg.width, aImg.width);
            const h = Math.max(tImg.height, aImg.height);
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Draw template to get pixel data
            ctx.drawImage(tImg, 0, 0, w, h);
            const tData = ctx.getImageData(0, 0, w, h);

            // Draw aligned to get pixel data
            ctx.drawImage(aImg, 0, 0, w, h);
            const aData = ctx.getImageData(0, 0, w, h);

            // Create magenta/green overlay
            const output = ctx.createImageData(w, h);
            for (let i = 0; i < tData.data.length; i += 4) {
                // Use grayscale luminance from each
                const tGray = (tData.data[i] * 0.299 + tData.data[i+1] * 0.587 + tData.data[i+2] * 0.114) / 255;
                const aGray = (aData.data[i] * 0.299 + aData.data[i+1] * 0.587 + aData.data[i+2] * 0.114) / 255;

                output.data[i]   = Math.min(255, Math.round(tGray * 255));   // R = template (magenta)
                output.data[i+1] = Math.min(255, Math.round(aGray * 255));   // G = aligned
                output.data[i+2] = Math.min(255, Math.round(tGray * 255));   // B = template (magenta)
                output.data[i+3] = 255;
            }
            ctx.putImageData(output, 0, 0);
        }

        async function drawBlendCanvas(axis, templateB64, alignedB64, alpha) {
            const canvas = document.getElementById(`canvas-${axis}`);
            if (!canvas) return;

            const [tImg, aImg] = await Promise.all([
                loadImageFromBase64(templateB64),
                loadImageFromBase64(alignedB64)
            ]);

            const w = Math.max(tImg.width, aImg.width);
            const h = Math.max(tImg.height, aImg.height);
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Draw template at (1 - alpha) opacity
            ctx.globalAlpha = 1 - alpha;
            ctx.drawImage(tImg, 0, 0, w, h);

            // Blend aligned on top at alpha opacity
            ctx.globalAlpha = alpha;
            ctx.drawImage(aImg, 0, 0, w, h);

            ctx.globalAlpha = 1.0;
        }

        // ────────────────────────────
        // Regenerate thumbnails
        // ────────────────────────────
        async function regenerateThumbnails() {
            const job = allJobs[currentIndex];
            if (!job) return;

            const btn = document.getElementById('regen-btn');
            btn.disabled = true;
            btn.textContent = 'Regenerating...';

            try {
                const res = await fetch('/api/regenerate-thumbnails', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_base: job.image_base })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed');

                // Clear cache and reload
                delete thumbnailCache[job.image_base];
                await selectImage(currentIndex);
                btn.textContent = '\u21BB Regenerate Thumbnails';
            } catch (err) {
                alert('Failed to regenerate thumbnails: ' + err.message);
                btn.textContent = '\u21BB Regenerate Thumbnails';
            } finally {
                btn.disabled = false;
            }
        }

        // ────────────────────────────
        // Approval / Rejection
        // ────────────────────────────
        async function approveAlignment() {
            const job = displayedJobs[currentIndex];
            if (!job) return;
            const btn = document.getElementById('approve-alignment-btn');
            btn.disabled = true;
            btn.textContent = 'Approving...';
            try {
                const res = await fetch('/api/approve-alignment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_base: job.image_base })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed');
                // Refresh orientations data
                orientationsData = await fetch('/api/saved').then(r => r.json());
                // Update saved key
                const key = Object.keys(orientationsData).find(k => k.split('/').pop() === job.image_base);
                if (key) job._savedKey = key;
                updateApprovalUI(job);
                applyGalleryFilter(currentGalleryFilter);
            } catch (err) {
                alert('Failed to approve alignment: ' + err.message);
            } finally {
                btn.textContent = '\u2713 Approve Alignment';
                btn.disabled = false;
            }
        }

        async function rejectAlignment() {
            const job = displayedJobs[currentIndex];
            if (!job) return;
            const reason = prompt('Reason for rejection (optional):');
            if (reason === null) return; // User cancelled
            const btn = document.getElementById('reject-alignment-btn');
            btn.disabled = true;
            btn.textContent = 'Rejecting...';
            try {
                const res = await fetch('/api/reject-alignment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_base: job.image_base, reason })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed');
                // Refresh data — the job may be removed from the list
                await loadData();
                closeDetail();
            } catch (err) {
                alert('Failed to reject alignment: ' + err.message);
            } finally {
                btn.textContent = '\u2717 Reject & Re-orient';
                btn.disabled = false;
            }
        }

        // ────────────────────────────
        // Signal on Template canvas
        // ────────────────────────────
        async function drawSignalOnTemplate(axis, templateB64, signalB64) {
            const canvas = document.getElementById(`sot-canvas-${axis}`);
            if (!canvas || !templateB64 || !signalB64) return;

            const [tImg, sImg] = await Promise.all([
                loadImageFromBase64(templateB64),
                loadImageFromBase64(signalB64)
            ]);

            const w = Math.max(tImg.width, sImg.width);
            const h = Math.max(tImg.height, sImg.height);
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Draw template for pixel data
            ctx.drawImage(tImg, 0, 0, w, h);
            const tData = ctx.getImageData(0, 0, w, h);

            // Draw signal for pixel data
            ctx.drawImage(sImg, 0, 0, w, h);
            const sData = ctx.getImageData(0, 0, w, h);

            // Create magenta (template) / green (signal) overlay
            const output = ctx.createImageData(w, h);
            for (let i = 0; i < tData.data.length; i += 4) {
                const tGray = (tData.data[i] * 0.299 + tData.data[i+1] * 0.587 + tData.data[i+2] * 0.114) / 255;
                const sGray = (sData.data[i] * 0.299 + sData.data[i+1] * 0.587 + sData.data[i+2] * 0.114) / 255;

                output.data[i]   = Math.min(255, Math.round(tGray * 255));   // R = template (magenta)
                output.data[i+1] = Math.min(255, Math.round(sGray * 255));   // G = signal
                output.data[i+2] = Math.min(255, Math.round(tGray * 255));   // B = template (magenta)
                output.data[i+3] = 255;
            }
            ctx.putImageData(output, 0, 0);
        }

        // ────────────────────────────
        // Navigation
        // ────────────────────────────
        function navigate(delta) {
            const newIdx = currentIndex + delta;
            if (newIdx >= 0 && newIdx < displayedJobs.length) {
                selectImage(newIdx);
            }
        }

        function updateNav() {
            document.getElementById('prev-btn').disabled = currentIndex <= 0;
            document.getElementById('next-btn').disabled = currentIndex >= displayedJobs.length - 1;
            document.getElementById('nav-position').textContent = `${currentIndex + 1} / ${displayedJobs.length}`;
        }

        function closeDetail() {
            document.getElementById('detail-panel').classList.remove('visible');
            currentIndex = -1;
            window.location.hash = '';
            document.querySelectorAll('.gallery-card').forEach(c => c.classList.remove('active'));
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (currentIndex < 0) return;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); navigate(-1); }
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') { e.preventDefault(); navigate(1); }
            if (e.key === 'Escape') { closeDetail(); }
        });

        // ────────────────────────────
        // Utilities
        // ────────────────────────────
        function formatTime(ts) {
            if (!ts) return '';
            const d = new Date(ts);
            return d.toLocaleDateString('en-GB') + ' ' + d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            if (!seconds || seconds < 0) return '';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        // ── Init ──
        loadData();
    </script>
</body>
</html>
